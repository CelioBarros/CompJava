package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
  
public void report_error(String message, Object info) {
   StringBuffer m = new StringBuffer("Erro encontrado na ");

String token = "";

if (info instanceof java_cup.runtime.Symbol) {
           java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
           token = s.value+"";

           if (s.left+1 >= 0) {
               /* Add to the end of the StringBuffer error message
                  the line number of the error in the input. */
               m.append("linha "+(s.left));   
               /* Check if the column number in the input is greater
                  or equal to zero. */
               if (s.right >= 0)                    
                   /* Add to the end of the StringBuffer error message
                      the column number of the error in the input. */
                   m.append(", coluna "+(s.right));
           }
       }
       m.append(" : "+message);
       System.err.println(m);
 }
  
 public void report_fatal_error(String message, Object info) {
   report_error(message, info);
   throw new RuntimeException("Erro fatal.");
 }

 
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PACKAGE, POINT, COMMA, IMPORT, MULT, CLASS, EXTENDS, IMPLEMENTS;
terminal			PUBLIC, PROTECTED, PRIVATE, STATIC, ABSTRACT, FINAL, NATIVE, SYNCHRONIZED;
terminal			TRANSIENT, VOLATILE, LBRACE, RBRACE, LBRACK, RBRACK, EQ, MOD, MODEQ, NOT;
terminal			MINUS, MINUSMINUS, PLUS, PLUSPLUS, PLUSEQ, MINUSEQ, MULTEQ, DIV, DIVEQ;
terminal			GT, LT, GTEQ, LTEQ, EQEQ, NOTEQ;
terminal			RETURN, THROW, BREAK, CONTINUE;
terminal			COMP, RSHIFTEQ, RSHIFT, SSHIFT, LSHIFT, LPAREN, RPAREN, NEW;
terminal			TRUE, FALSE, QUESTION, COLON, AMPERSAND, AMPERSANDEQ, OR, OROR, OREQ, OROREQ;
terminal			BOOLEAN, BYTE, CHAR, SHORT, INT, FLOAT, LONG, DOUBLE, XOREQ, XOR;
terminal			INTEGER_LITERAL, INTEGER_LITERAL_LONG, HEX_LITERAL, HEX_LITERAL_LONG;
terminal			OCT_LITERAL, OCT_LITERAL_LONG, FLOAT_LITERAL;
terminal			NULL, SUPER, THIS, INSTANCEOF, IF, ELSE, DO, WHILE, FOR, TRY, CATCH, FINALLY;
terminal			SWITCH, CASE, DEFAULT, INTERFACE;
terminal String     IDENTIFIER;
terminal Character	CHARACTER_LITERAL;
terminal String 	STRING_LITERAL;

/* Non terminals */
non terminal            inicio;
non terminal            compilation_unit, package_statement_opt, package_statement, name;
non terminal            import_statement_opt, import_statements, import_statement;
non terminal            type_declarations_opt, type_declarations, type_declaration;
non terminal			class_declaration;
non terminal			modifiers_opt, modifiers, modifier;
non terminal			super_opt, super_cl, interfaces_opt, interfaces, interface_type_list;
non terminal			field_aux, field_declaration, field_declarations_opt, field_declarations;
non terminal			static_initializer;
non terminal			statement_block, statements_opt, statements, statement;
non terminal			variable_declaration, variable_declarator, variable_initializer_opt;
non terminal			variable_initializer, variable_initializers, array_initializer;
non terminal			type, type_specifier, variable_declarators;
non terminal			bracks_opt, bracks, brack, return_opt, break_opt, continue_opt;
non terminal			expression, numeric_expression, num_const;
non terminal			testing_expression, test_const, logical_expression, logical_const;
non terminal			string_expression, bit_expression, bit_const, casting_expression;
non terminal			creating_expression, creating_expression_alt, arglist, array_expression_opt;
non terminal			literal_expression, integer_literal_desc, string, num_logic_expression;
non terminal			if_statement, else_opt, do_statement, while_statement, parameter, switch_statement;
non terminal			for_statement, for_var_exp, expression_opt, try_statement, statements_try, try_opt;
non terminal			statements_switch_opt, statements_switch, statement_switch;
non terminal			mcv_declarations, parameter_list, statement_aux, method_declaration;
non terminal			constructor_declaration, parameter_list_opt, interface_declaration, inter_opt;

/* Precedences */
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left MOD;
precedence left NOT; 
precedence left LPAREN;
precedence left ELSE;
precedence left POINT;
precedence left COMMA;
precedence left INSTANCEOF;
precedence left TRY, CATCH, FINALLY;
precedence right SEMI;
precedence right PLUSEQ, MINUSEQ;
precedence right MULTEQ, DIVEQ;
precedence right MODEQ;
precedence right PLUSPLUS, MINUSMINUS;
precedence left SSHIFT, RSHIFT, LSHIFT, RSHIFTEQ;
precedence left LBRACK;
precedence left GT, LT, GTEQ, LTEQ, EQEQ, NOTEQ, QUESTION;
precedence left IDENTIFIER;

precedence right AMPERSAND, AMPERSANDEQ, OR, OROR, OREQ, OROREQ, XOR, XOREQ;

/* The grammar rules */
inicio ::= compilation_unit
            ;
            
compilation_unit ::= package_statement_opt import_statement_opt type_declarations_opt
			         ;
			            
package_statement_opt ::= package_statement
			|                                        
			;
			
package_statement ::= PACKAGE name SEMI
			;
			
name ::= IDENTIFIER
			| name POINT IDENTIFIER
			;
			
import_statement_opt ::= import_statements
							|
							;

import_statements ::= import_statement
						| import_statements import_statement
						;

import_statement ::= IMPORT name SEMI
						| IMPORT name POINT MULT SEMI
						;

type_declarations_opt ::= type_declarations
						|
						;
						
type_declarations ::= type_declaration
					| type_declarations type_declaration
					;
					
type_declaration ::= class_declaration
					| interface_declaration
					;

class_declaration ::= modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt field_aux
					;
						

modifiers_opt ::= modifiers
		|
		;
modifiers ::= modifier
		| modifiers modifier
		;
		
modifier ::= PUBLIC
		| PROTECTED
		| PRIVATE
		| STATIC
		| ABSTRACT
		| FINAL
		| NATIVE
		| SYNCHRONIZED
		| TRANSIENT
		| VOLATILE
		;
		
super_cl ::= EXTENDS name
	;
super_opt ::= super_cl	
	|
	;
	
interfaces ::= IMPLEMENTS interface_type_list
	;
interfaces_opt ::= interfaces
	|
	;
interface_type_list ::= name
	| interface_type_list COMMA name
	;
	
field_aux ::= LBRACE field_declarations_opt RBRACE
	;
	
field_declarations_opt ::= field_declarations
	|
	;
	
field_declarations ::= field_declaration
	| field_declarations field_declaration
	;
	
field_declaration ::= mcv_declarations
	| static_initializer
	| SEMI
	;
	
static_initializer ::= STATIC statement_block
	;
	
statement_block ::= LBRACE statements_opt RBRACE
	;
	
statements_opt ::= statements
	|
	;
statements ::= statement
	| statements statement
	;
	
statement ::= variable_declaration
	  | expression SEMI
      | statement_block 
      | if_statement 
      | do_statement 
      | while_statement 
      | for_statement 
      | try_statement 
      | switch_statement 
      | SYNCHRONIZED LPAREN expression RPAREN statement
      | return_opt 
      | THROW expression SEMI
      | IDENTIFIER COLON statement 
      | break_opt 
      | continue_opt 
      | SEMI
	;	

return_opt ::= RETURN SEMI
	| RETURN expression SEMI
	;
break_opt ::= BREAK SEMI
	| BREAK IDENTIFIER SEMI
	;
continue_opt ::= CONTINUE SEMI
	| CONTINUE IDENTIFIER SEMI
	;
variable_declaration ::= modifiers_opt type variable_declarators SEMI
	;

type ::= type_specifier bracks_opt
	;
	
type_specifier ::= BOOLEAN
	| BYTE
	| CHAR
	| SHORT
	| INT
	| FLOAT
	| LONG
	| DOUBLE
	| name
	;
	
bracks_opt ::= bracks
	|
	;
	
bracks ::= brack
	| bracks brack
	;
	
brack ::= LBRACK RBRACK
	;
	
variable_declarators ::= variable_declarator
	| variable_declarators COMMA variable_declarator
	;
	
variable_declarator ::= IDENTIFIER bracks_opt variable_initializer_opt
	;

variable_initializer_opt ::= EQ variable_initializer
	|
	;

variable_initializer ::= expression
	| array_initializer
	;
	
array_initializer ::= LBRACE variable_initializers COMMA RBRACE
	|	LBRACE variable_initializers RBRACE
	|	LBRACE RBRACE
	;
	
variable_initializers ::= variable_initializer
	|	variable_initializers COMMA variable_initializer
	;
	
expression ::= numeric_expression
	| testing_expression
	| logical_expression
	| string_expression                
    | bit_expression
    | casting_expression 
    | creating_expression 
    | literal_expression 
    | NULL
	| SUPER
	| THIS
    | IDENTIFIER 
    | num_logic_expression
    | expression LPAREN RPAREN
    | expression LPAREN arglist RPAREN
    | expression LBRACK expression RBRACK
    | expression POINT expression
    | expression COMMA expression
    | expression INSTANCEOF name
    ;
    
num_logic_expression ::= expression MODEQ expression 
	| expression MOD expression
	;     
      
numeric_expression ::= MINUS expression 
      | PLUSPLUS expression
      | MINUSMINUS expression 
      | expression PLUSPLUS 
      | expression MINUSMINUS
      | expression num_const expression
      ;

num_const ::= PLUS
      | PLUSEQ
      | MINUS
      | MINUSEQ
      | MULT
      | MULTEQ
      | DIV
      | DIVEQ
      ;
      
testing_expression ::= expression test_const expression
	;
	
test_const ::= GT
	| LT
	| GTEQ
	| LTEQ
	| EQEQ
	| NOTEQ
	;
	
logical_expression ::= NOT expression 
      | expression logical_const expression
      | expression QUESTION expression COLON expression 
      | TRUE
      | FALSE 
      ;
      
logical_const ::= AMPERSAND
      | AMPERSANDEQ
      | OR 
      | OREQ
      | XOR 
      | XOREQ 
      | AMPERSAND AMPERSAND 
      | OROREQ
      ;
      
string_expression ::= expression PLUS expression
	| expression PLUSEQ expression
	;
	
bit_expression ::= COMP expression
	| expression bit_const expression
	;
	
bit_const ::= SSHIFT
	| RSHIFT
	| LSHIFT
	| RSHIFTEQ
	;
	
casting_expression ::= LPAREN type RPAREN expression
	;
	
creating_expression ::= NEW creating_expression_alt
	;
	
creating_expression_alt ::= name LPAREN arglist RPAREN
	| type_specifier array_expression_opt bracks_opt
	| LPAREN expression RPAREN
	;
	
arglist ::= expression
	| arglist COMMA expression
	;
	
array_expression_opt ::= LBRACK expression RBRACK
	|
	;
	

literal_expression ::= integer_literal_desc 
    | FLOAT_LITERAL
    | STRING_LITERAL 
    | CHARACTER_LITERAL
    ;

integer_literal_desc ::= INTEGER_LITERAL
	| INTEGER_LITERAL_LONG
	| HEX_LITERAL
	| HEX_LITERAL_LONG
	| OCT_LITERAL
	| OCT_LITERAL_LONG
	;

if_statement ::= IF LPAREN expression RPAREN statement else_opt
	;
	
else_opt ::= ELSE statement
	|
	;
	
do_statement ::= DO statement WHILE LPAREN expression RPAREN SEMI
	;
	
while_statement ::= WHILE LPAREN expression RPAREN statement
	;
	
for_statement ::= FOR LPAREN for_var_exp expression_opt SEMI expression_opt SEMI RPAREN statement
	;
	
for_var_exp ::= variable_declaration
	| expression SEMI
	| SEMI
	;
	
expression_opt ::= expression
	|
	;
	
try_statement ::= TRY statements_try try_opt
	;
	
statements_try ::= statement
	| statements_try CATCH LPAREN parameter RPAREN statement
	;
	
try_opt ::= FINALLY statement
	|
	;
	
parameter ::= type IDENTIFIER bracks_opt
	;

switch_statement ::= SWITCH LPAREN expression RPAREN LBRACE statements_switch_opt RBRACE
	;
	
statements_switch_opt ::= statements_switch
	|
	;
	
statements_switch ::= statement_switch
	| statements_switch statement_switch
	;
	
statement_switch ::= CASE expression COLON
	| DEFAULT COLON
	| statement
	;
	
mcv_declarations ::= method_declaration
	| constructor_declaration
	| variable_declaration
	;

method_declaration ::= modifiers_opt type IDENTIFIER LPAREN parameter_list_opt RPAREN bracks_opt statement_aux
	;
	
parameter_list_opt ::= parameter_list
	|
	;
	
parameter_list ::= parameter
	| parameter_list COMMA parameter
	;
	
statement_aux ::= statement_block
	| SEMI
	;
	
constructor_declaration ::= modifiers_opt IDENTIFIER LPAREN parameter_list_opt RPAREN statement_block
	;
	
interface_declaration ::=  modifiers_opt INTERFACE IDENTIFIER inter_opt LBRACE field_declarations_opt RBRACE
	;
	
inter_opt ::= EXTENDS interface_type_list
	|
	;
	
