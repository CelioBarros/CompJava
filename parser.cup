package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
  
  
  public void report_error(String message, Object info) {
   StringBuffer m = new StringBuffer("Erro encontrado na ");

String token = "";

if (info instanceof java_cup.runtime.Symbol) {
           java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
           token = s.value+"";
           if (s.left >= 0) {
               /* Add to the end of the StringBuffer error message
                  the line number of the error in the input. */
               m.append("linha "+(s.left));  
               /* Check if the column number in the input is greater
                  or equal to zero. */
               if (s.right >= 0)                    
                   /* Add to the end of the StringBuffer error message
                      the column number of the error in the input. */
                   m.append(", coluna "+(s.right));
           }
       }
       m.append(" : "+message);
       System.err.println(m);
 }
 
 public void report_fatal_error(String message, Object info) {
   report_error(message, info);
   throw new RuntimeException("Erro fatal.");
 }
 
 
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PACKAGE, POINT, COMMA, IMPORT, MULT, CLASS, EXTENDS, IMPLEMENTS;
terminal			PUBLIC, PROTECTED, PRIVATE, STATIC, ABSTRACT, FINAL, NATIVE, SYNCHRONIZED;
terminal			TRANSIENT, VOLATILE, LBRACE, RBRACE;
terminal String     IDENTIFIER;

/* Non terminals */
non terminal            inicio;
non terminal            compilation_unit, package_statement_opt, package_statement, name;
non terminal            import_statement_opt, import_statements, import_statement;
non terminal            type_declarations_opt, type_declarations, type_declaration;
non terminal			class_declaration;
non terminal			modifiers_opt, modifiers, modifier;
non terminal			super_opt, super_cl, interfaces_opt, interfaces, interface_type_list;
non terminal			field_aux, field_declaration;
non terminal			static_initializer, statement_block;

/* Precedences */

/* The grammar rules */
inicio ::= inicio compilation_unit SEMI
            | compilation_unit SEMI
            ;
            
compilation_unit ::= package_statement_opt import_statement_opt type_declarations_opt
			         ;
			            
package_statement_opt ::= package_statement
			|                                        
			;
			
package_statement ::= PACKAGE name SEMI
			;
			
name ::= IDENTIFIER
			| name POINT IDENTIFIER
			;
			
import_statement_opt ::= import_statements
							|
							;

import_statements ::= import_statement
						| import_statements import_statement
						;

import_statement ::= IMPORT name SEMI
						| IMPORT name POINT MULT SEMI
						;

type_declarations_opt ::= type_declarations
						|
						;
						
type_declarations ::= type_declaration
					| type_declarations type_declaration
					;
					
type_declaration ::= class_declaration
					//| CLASS name IMPORT // interface_declaration
					;

class_declaration ::= modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt field_aux
					;
						

modifiers_opt ::= modifiers
		|
		;
modifiers ::= modifier
		| modifiers modifier
		;
		
modifier ::= PUBLIC
		| PROTECTED
		| PRIVATE
		| STATIC
		| ABSTRACT
		| FINAL
		| NATIVE
		| SYNCHRONIZED
		| TRANSIENT
		| VOLATILE
		;
		
super_cl ::= EXTENDS name
	;
super_opt ::= super_cl	
	|
	;
	
interfaces ::= IMPLEMENTS interface_type_list
	;
interfaces_opt ::= interfaces
	|
	;
interface_type_list ::= name
	| interface_type_list COMMA name
	;
	
field_aux ::= LBRACE field_declaration RBRACE
	;
	
field_declaration ::= name // declarar corretamente
	| static_initializer
	| SEMI
	;
	
static_initializer ::= STATIC statement_block
	;
	
statement_block ::= LBRACE name RBRACE // terminar
	;