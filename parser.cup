package cup.example;

import java_cup.runtime.*;
import cup.example.Lexer;
import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;

parser code {:
  protected Lexer lexer;
  

 
:}

/* define how to connect to the scanner! */
init with {:
  ComplexSymbolFactory f = new ComplexSymbolFactory();
  symbolFactory = f;
  File file = new File("input.txt");
  FileInputStream fis = null;
  try {
    fis = new FileInputStream(file);
  } catch (IOException e) {
    e.printStackTrace();
  } 
  lexer = new Lexer(f,fis);
:};
scan with {: return lexer.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal            SEMI, PACKAGE, POINT, COMMA, IMPORT, MULT, CLASS, EXTENDS, IMPLEMENTS;
terminal			PUBLIC, PROTECTED, PRIVATE, STATIC, ABSTRACT, FINAL, NATIVE, SYNCHRONIZED;
terminal			TRANSIENT, VOLATILE, LBRACE, RBRACE, LBRACK, RBRACK, EQ, MOD, MODEQ, NOT;
terminal			MINUS, MINUSMINUS, PLUS, PLUSPLUS, PLUSEQ, MINUSEQ, MULTEQ, DIV, DIVEQ;
terminal			GT, LT, GTEQ, LTEQ, EQEQ, NOTEQ;
terminal			COMP, RSHIFTEQ, RSHIFT, SSHIFT, LSHIFT, LPAREN, RPAREN, NEW;
terminal			TRUE, FALSE, QUESTION, COLON, AMPERSAND, AMPERSANDEQ, OR, OROR, OREQ, OROREQ;
terminal			BOOLEAN, BYTE, CHAR, SHORT, INT, FLOAT, LONG, DOUBLE, XOREQ, XOR;
terminal			INTEGER_LITERAL, INTEGER_LITERAL_LONG, HEX_LITERAL, HEX_LITERAL_LONG;
terminal			OCT_LITERAL, OCT_LITERAL_LONG, FLOAT_LITERAL;
terminal			NULL, SUPER, THIS, INSTANCEOF;
terminal String     IDENTIFIER;
terminal Character	CHARACTER_LITERAL;
terminal String 	STRING_LITERAL;

/* Non terminals */
non terminal            inicio;
non terminal            compilation_unit, package_statement_opt, package_statement, name;
non terminal            import_statement_opt, import_statements, import_statement;
non terminal            type_declarations_opt, type_declarations, type_declaration;
non terminal			class_declaration;
non terminal			modifiers_opt, modifiers, modifier;
non terminal			super_opt, super_cl, interfaces_opt, interfaces, interface_type_list;
non terminal			field_aux, field_declaration, field_declarations_opt, field_declarations;
non terminal			static_initializer;
non terminal			statement_block, statements_opt, statements, statement;
non terminal			variable_declaration, variable_declarator, variable_initializer_opt;
non terminal			variable_initializer, variable_initializers, array_initializer;
non terminal			type, type_specifier;
non terminal			bracks_opt, bracks, brack;
non terminal			expression, numeric_expression, num_const, brack_list_opt, brack_list;
non terminal			testing_expression, test_const, logical_expression, logical_const;
non terminal			string_expression, bit_expression, bit_const, casting_expression;
non terminal			creating_expression, creating_expression_alt, arglist, array_expression_opt;
non terminal			literal_expression, integer_literal_desc, string;

/* Precedences */
precedence left PLUS, MINUS;
precedence left MULT, DIV;
precedence left MOD;
precedence left NOT; 
precedence right PLUSEQ, MINUSEQ;
precedence right MULTEQ, DIVEQ;
precedence right MODEQ;
precedence right PLUSPLUS, MINUSMINUS;
precedence left SSHIFT, RSHIFT, LSHIFT, RSHIFTEQ;
precedence left LBRACK;
precedence left GT, LT, GTEQ, LTEQ, EQEQ, NOTEQ, QUESTION;

precedence right AMPERSAND, AMPERSANDEQ, OR, OROR, OREQ, OROREQ, XOR, XOREQ;

/* The grammar rules */
inicio ::= inicio compilation_unit SEMI
            | compilation_unit SEMI
            ;
            
compilation_unit ::= package_statement_opt import_statement_opt type_declarations_opt
			         ;
			            
package_statement_opt ::= package_statement
			|                                        
			;
			
package_statement ::= PACKAGE name SEMI
			;
			
name ::= IDENTIFIER
			| name POINT IDENTIFIER
			;
			
import_statement_opt ::= import_statements
							|
							;

import_statements ::= import_statement
						| import_statements import_statement
						;

import_statement ::= IMPORT name SEMI
						| IMPORT name POINT MULT SEMI
						;

type_declarations_opt ::= type_declarations
						|
						;
						
type_declarations ::= type_declaration
					| type_declarations type_declaration
					;
					
type_declaration ::= class_declaration
					//| CLASS name IMPORT // interface_declaration
					;

class_declaration ::= modifiers_opt CLASS IDENTIFIER super_opt interfaces_opt field_aux
					;
						

modifiers_opt ::= modifiers
		|
		;
modifiers ::= modifier
		| modifiers modifier
		;
		
modifier ::= PUBLIC
		| PROTECTED
		| PRIVATE
		| STATIC
		| ABSTRACT
		| FINAL
		| NATIVE
		| SYNCHRONIZED
		| TRANSIENT
		| VOLATILE
		;
		
super_cl ::= EXTENDS name
	;
super_opt ::= super_cl	
	|
	;
	
interfaces ::= IMPLEMENTS interface_type_list
	;
interfaces_opt ::= interfaces
	|
	;
interface_type_list ::= name
	| interface_type_list COMMA name
	;
	
field_aux ::= LBRACE field_declarations_opt RBRACE
	;
	
field_declarations_opt ::= field_declarations
	|
	;
	
field_declarations ::= field_declaration
	| field_declarations field_declaration
	;
	
field_declaration ::= name // declarar corretamente
	| static_initializer
	| SEMI
	;
	
static_initializer ::= STATIC statement_block
	;
	
statement_block ::= LBRACE statements_opt RBRACE
	;
	
statements_opt ::= statements
	|
	;
statements ::= statement
	| statements statement
	;
	
statement ::= variable_declaration
/*      | ( expression ";" ) 
      | ( statement_block ) 
      | ( if_statement ) 
      | ( do_statement ) 
      | ( while_statement ) 
      | ( for_statement ) 
      | ( try_statement ) 
      | ( switch_statement ) 
      | ( "synchronized" "(" expression ")" statement ) 
      | ( "return" [ expression ] ";" ) 
      | ( "throw" expression ";" ) 
      | ( identifier ":" statement ) 
      | ( "break" [ identifier ] ";" ) 
      | ( "continue" [ identifier ] ";" ) 
      | ( ";" )  */
	;	

variable_declaration ::= modifiers_opt type variable_declarator // terminar
	;

type ::= type_specifier bracks_opt
	;
	
type_specifier ::= BOOLEAN
	| BYTE
	| CHAR
	| SHORT
	| INT
	| FLOAT
	| LONG
	| DOUBLE
	| name
	;
	
bracks_opt ::= bracks
	|
	;
	
bracks ::= brack
	| bracks brack
	;
	
brack ::= LBRACK RBRACK
	;
	
variable_declarator ::= IDENTIFIER bracks_opt variable_initializer_opt
	;

variable_initializer_opt ::= EQ variable_initializer
	|
	;

variable_initializer ::= expression
	| array_initializer
	;
	
array_initializer ::= LBRACE variable_initializers COMMA RBRACE
	|	LBRACE variable_initializers RBRACE
	|	LBRACE RBRACE
	;
	
variable_initializers ::= variable_initializer
	|	variable_initializers COMMA variable_initializer
	;
	
expression ::= numeric_expression
	| testing_expression
	| logical_expression
	| string_expression                
    | bit_expression
    | casting_expression 
    | creating_expression 
    | literal_expression 
    | NULL
	| SUPER
	| THIS
    | IDENTIFIER 
    /*  | ( "(" expression ")" ) 
      | ( expression 
      ( ( "(" [ arglist ] ")" ) 
      | ( "[" expression "]" ) 
      | ( "." expression ) 
      | ( "," expression ) 
      | ( "instanceof" ( class_name | interface_name ) ) 
      ) )*/
    ;
      
numeric_expression ::= MINUS expression 
      | PLUSPLUS expression
      | MINUSMINUS expression 
      | expression PLUSPLUS 
      | expression MINUSMINUS
      | expression num_const expression
      ;

num_const ::= PLUS
      | PLUSEQ
      | MINUS
      | MINUSEQ
      | MULT
      | MULTEQ
      | DIV
      | DIVEQ
      | MOD
      | MODEQ
      ;
      
testing_expression ::= expression test_const expression
	;
	
test_const ::= GT
	| LT
	| GTEQ
	| LTEQ
	| EQEQ
	| NOTEQ
	;
	
logical_expression ::= NOT expression 
      | logical_expression logical_const expression
      | expression QUESTION expression COLON expression 
      | TRUE
      | FALSE 
      ;
      
logical_const ::= AMPERSAND
      | AMPERSANDEQ
      | OR 
      | OREQ
      | XOR 
      | XOREQ 
      | AMPERSAND AMPERSAND 
      | OROREQ
      | MOD
      | MODEQ
      ;
      
string_expression ::= string_expression PLUS expression
	| string_expression PLUSEQ expression
	;
	
bit_expression ::= COMP expression
	| bit_expression bit_const expression
	;
	
bit_const ::= SSHIFT
	| RSHIFT
	| LSHIFT
	| RSHIFTEQ
	;
	
casting_expression ::= LPAREN type RPAREN expression
	;
	
creating_expression ::= NEW creating_expression_alt
	;
	
creating_expression_alt ::= name LPAREN arglist RPAREN
	| type_specifier array_expression_opt brack_list_opt
	| LPAREN expression RPAREN
	;
	
arglist ::= expression
	| arglist COMMA expression
	;
	
array_expression_opt ::= LBRACK expression RBRACK
	|
	;

brack_list_opt ::= brack_list
	| 
	;
	
brack_list ::= LBRACK RBRACK
	| brack_list LBRACK RBRACK
	;

literal_expression ::= integer_literal_desc 
    | FLOAT_LITERAL
    | STRING_LITERAL 
    | CHARACTER_LITERAL
    ;

integer_literal_desc ::= INTEGER_LITERAL
	| INTEGER_LITERAL_LONG
	| HEX_LITERAL
	| HEX_LITERAL_LONG
	| OCT_LITERAL
	| OCT_LITERAL_LONG
	;

